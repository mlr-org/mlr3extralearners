<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Survival Flexible Parametric Spline Learner — mlr_learners_surv.flexible • mlr3extralearners</title><!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png"><link rel="icon" type="”image/svg+xml”" href="../favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png"><link rel="icon" sizes="any" href="../favicon.ico"><link rel="manifest" href="../site.webmanifest"><!-- mathjax math --><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    chtml: {
      fontURL: "https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/output/chtml/fonts/woff-v2"
    }
  };
</script><script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Roboto-0.4.10/font.css" rel="stylesheet"><link href="../deps/JetBrains_Mono-0.4.10/font.css" rel="stylesheet"><link href="../deps/Roboto_Slab-0.4.10/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Survival Flexible Parametric Spline Learner — mlr_learners_surv.flexible"><meta name="description" content="Flexible parametric spline learner.
Calls flexsurv::flexsurvspline() from flexsurv."><meta property="og:description" content="Flexible parametric spline learner.
Calls flexsurv::flexsurvspline() from flexsurv."><meta name="robots" content="noindex"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">mlr3extralearners</a>

    <small class="nav-text text-default me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">1.2.0-9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html"><span class="fa fa-file-alt"></span> Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://mlr3book.mlr-org.com"><span class="fa fa-link"></span> mlr3book</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/learner_status.html">Learner Status</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/extending.html">Extending</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/common_issues.html">Common Issues</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mlr-org/mlr3extralearners"><span class="fa fa-github"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://lmmisld-lmu-stats-slds.srv.mwn.de/mlr_invite/"><span class="fa fa-comments"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://stackoverflow.com/questions/tagged/mlr3"><span class="fa fab fa-stack-overflow"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://mlr-org.com/"><span class="fa fa-rss"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch"><li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Survival Flexible Parametric Spline Learner</h1>
      <small class="dont-index">Source: <a href="https://github.com/mlr-org/mlr3extralearners/blob/main/R/learner_flexsurv_surv_flexible.R" class="external-link"><code>R/learner_flexsurv_surv_flexible.R</code></a></small>
      <div class="d-none name"><code>mlr_learners_surv.flexible.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Flexible parametric spline learner.
Calls <code><a href="http://chjackson.github.io/flexsurv-dev/reference/flexsurvspline.html" class="external-link">flexsurv::flexsurvspline()</a></code> from <a href="https://CRAN.R-project.org/package=flexsurv" class="external-link"><span class="pkg">flexsurv</span></a>.</p>
    </div>


    <div class="section level2">
    <h2 id="dictionary">Dictionary<a class="anchor" aria-label="anchor" href="#dictionary"></a></h2>


<p>This <a href="https://mlr3.mlr-org.com/reference/Learner.html" class="external-link">Learner</a> can be instantiated via <a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html" class="external-link">lrn()</a>:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"surv.flexible"</span>)</span></code></pre><p></p></div>
    </div>
    <div class="section level2">
    <h2 id="meta-information">Meta Information<a class="anchor" aria-label="anchor" href="#meta-information"></a></h2>


<ul><li><p>Task type: “surv”</p></li>
<li><p>Predict Types: “crank”, “distr”, “lp”</p></li>
<li><p>Feature Types: “logical”, “integer”, “numeric”, “factor”</p></li>
<li><p>Required Packages: <a href="https://CRAN.R-project.org/package=mlr3" class="external-link"><span class="pkg">mlr3</span></a>, <a href="https://CRAN.R-project.org/package=mlr3proba" class="external-link"><span class="pkg">mlr3proba</span></a>, <a href="https://CRAN.R-project.org/package=mlr3extralearners" class="external-link"><span class="pkg">mlr3extralearners</span></a>, <a href="https://CRAN.R-project.org/package=flexsurv" class="external-link"><span class="pkg">flexsurv</span></a></p></li>
</ul></div>
    <div class="section level2">
    <h2 id="parameters">Parameters<a class="anchor" aria-label="anchor" href="#parameters"></a></h2>

<table class="table table"><tr><td>Id</td><td>Type</td><td>Default</td><td>Levels</td><td>Range</td></tr><tr><td>formula</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>bhazard</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>k</td><td>integer</td><td>0</td><td></td><td>\([0, \infty)\)</td></tr><tr><td>knots</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>bknots</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>scale</td><td>character</td><td>hazard</td><td>hazard, odds, normal</td><td>-</td></tr><tr><td>timescale</td><td>character</td><td>log</td><td>log, identity</td><td>-</td></tr><tr><td>spline</td><td>character</td><td>rp</td><td>rp, splines2ns</td><td>-</td></tr><tr><td>rtrunc</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>inits</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>fixedpars</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>cl</td><td>numeric</td><td>0.95</td><td></td><td>\([0, 1]\)</td></tr><tr><td>anc</td><td>untyped</td><td>-</td><td></td><td>-</td></tr><tr><td>maxiter</td><td>integer</td><td>30</td><td></td><td>\((-\infty, \infty)\)</td></tr><tr><td>rel.tolerance</td><td>numeric</td><td>1e-09</td><td></td><td>\((-\infty, \infty)\)</td></tr><tr><td>toler.chol</td><td>numeric</td><td>1e-10</td><td></td><td>\((-\infty, \infty)\)</td></tr><tr><td>debug</td><td>integer</td><td>0</td><td></td><td>\([0, 1]\)</td></tr><tr><td>outer.max</td><td>integer</td><td>10</td><td></td><td>\((-\infty, \infty)\)</td></tr></table></div>
    <div class="section level2">
    <h2 id="prediction-types">Prediction types<a class="anchor" aria-label="anchor" href="#prediction-types"></a></h2>


<p>This learner returns three prediction types:</p><ol><li><p><code>lp</code>: a vector containing the linear predictors (relative risk scores),
where each score corresponds to a specific test observation.
Calculated using <code><a href="http://chjackson.github.io/flexsurv-dev/reference/flexsurvspline.html" class="external-link">flexsurv::flexsurvspline()</a></code> and the estimated coefficients.
For fitted coefficients, \(\hat{\beta} = (\hat{\beta_0},...,\hat{\beta_P})\),
and the test data covariates \(X^T = (X_0,...,X_P)^T\), where \(X_0\)
is a column of \(1\)s and \(\hat{\beta_0} = \hat{\gamma_0}\), the linear predictor
vector is \(lp = \hat{\beta} X^T\).</p></li>
<li><p><code>distr</code>: a survival matrix in two dimensions, where observations are
represented in rows and time points in columns.
Calculated using <code>predict.flexsurvreg(type = "survival", ...)</code>.</p></li>
<li><p><code>crank</code>: same as <code>lp</code>.</p></li>
<li><p><code>response</code>: mean survival time calculated using <code>predict.flexsurvreg(type = "response", ...)</code></p></li>
</ol></div>
    <div class="section level2">
    <h2 id="initial-parameter-values">Initial parameter values<a class="anchor" aria-label="anchor" href="#initial-parameter-values"></a></h2>


<ul><li><p><code>k</code>:</p><ul><li><p>Actual default: <code>0</code></p></li>
<li><p>Initial value: <code>1</code></p></li>
<li><p>Reason for change: The default value of <code>0</code> is equivalent to, and a much less efficient
implementation of, <a href="mlr_learners_surv.parametric.html">LearnerSurvParametric</a>.</p></li>
</ul></li>
</ul></div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Royston, Patrick, Parmar, KB M (2002).
“Flexible parametric proportional-hazards and proportional-odds models for censored survival data, with application to prognostic modelling and estimation of treatment effects.”
<em>Statistics in medicine</em>, <b>21</b>(15), 2175–2197.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index">
<ul><li><p><a href="https://mlr3misc.mlr-org.com/reference/Dictionary.html" class="external-link">Dictionary</a> of <a href="https://mlr3.mlr-org.com/reference/Learner.html" class="external-link">Learners</a>: <a href="https://mlr3.mlr-org.com/reference/mlr_learners.html" class="external-link">mlr3::mlr_learners</a>.</p></li>
<li><p><code>as.data.table(mlr_learners)</code> for a table of available <a href="https://mlr3.mlr-org.com/reference/Learner.html" class="external-link">Learners</a> in the running session (depending on the loaded packages).</p></li>
<li><p>Chapter in the <a href="https://mlr3book.mlr-org.com/" class="external-link">mlr3book</a>: <a href="https://mlr3book.mlr-org.com/basics.html#learners" class="external-link">https://mlr3book.mlr-org.com/basics.html#learners</a></p></li>
<li><p><a href="https://CRAN.R-project.org/package=mlr3learners" class="external-link"><span class="pkg">mlr3learners</span></a> for a selection of recommended learners.</p></li>
<li><p><a href="https://CRAN.R-project.org/package=mlr3cluster" class="external-link"><span class="pkg">mlr3cluster</span></a> for unsupervised clustering learners.</p></li>
<li><p><a href="https://CRAN.R-project.org/package=mlr3pipelines" class="external-link"><span class="pkg">mlr3pipelines</span></a> to combine learners with pre- and postprocessing steps.</p></li>
<li><p><a href="https://CRAN.R-project.org/package=mlr3tuning" class="external-link"><span class="pkg">mlr3tuning</span></a> for tuning of hyperparameters, <a href="https://CRAN.R-project.org/package=mlr3tuningspaces" class="external-link"><span class="pkg">mlr3tuningspaces</span></a> for established default tuning spaces.</p></li>
</ul></div>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>RaphaelS1</p>
    </div>
    <div class="section level2">
    <h2 id="super-classes">Super classes<a class="anchor" aria-label="anchor" href="#super-classes"></a></h2>
    <p><code><a href="https://mlr3.mlr-org.com/reference/Learner.html" class="external-link">mlr3::Learner</a></code> -&gt; <code><a href="https://mlr3proba.mlr-org.com/reference/LearnerSurv.html" class="external-link">mlr3proba::LearnerSurv</a></code> -&gt; <code>LearnerSurvFlexible</code></p>
    </div>
    <div class="section level2">
    <h2 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a></h2>

<div class="section">
<h3 id="public-methods">Public methods<a class="anchor" aria-label="anchor" href="#public-methods"></a></h3>

<ul><li><p><a href="#method-LearnerSurvFlexible-new"><code>LearnerSurvFlexible$new()</code></a></p></li>
<li><p><a href="#method-LearnerSurvFlexible-clone"><code>LearnerSurvFlexible$clone()</code></a></p></li>
</ul></div><p><details><summary>Inherited methods</summary><ul><li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="base_learner"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-base_learner"><code>mlr3::Learner$base_learner()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="configure"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-configure"><code>mlr3::Learner$configure()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="encapsulate"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-encapsulate"><code>mlr3::Learner$encapsulate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="format"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-format"><code>mlr3::Learner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="help"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-help"><code>mlr3::Learner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-predict"><code>mlr3::Learner$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict_newdata"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-predict_newdata"><code>mlr3::Learner$predict_newdata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="print"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-print"><code>mlr3::Learner$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="reset"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-reset"><code>mlr3::Learner$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="selected_features"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-selected_features"><code>mlr3::Learner$selected_features()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="train"><a href="https://mlr3.mlr-org.com/reference/Learner.html#method-train"><code>mlr3::Learner$train()</code></a></span></li>
</ul></details></p><hr><a id="method-LearnerSurvFlexible-new"></a><div class="section">
<h3 id="method-new-">Method <code>new()</code><a class="anchor" aria-label="anchor" href="#method-new-"></a></h3>
<p>Creates a new instance of this <a href="https://r6.r-lib.org/reference/R6Class.html" class="external-link">R6</a> class.</p><div class="section">
<h4 id="usage">Usage<a class="anchor" aria-label="anchor" href="#usage"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va"><a href="../reference/mlr_learners_surv.flexible.html">LearnerSurvFlexible</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>


</div><p></p><hr><a id="method-LearnerSurvFlexible-clone"></a><div class="section">
<h3 id="method-clone-">Method <code>clone()</code><a class="anchor" aria-label="anchor" href="#method-clone-"></a></h3>
<p>The objects of this class are cloneable with this method.</p><div class="section">
<h4 id="usage-1">Usage<a class="anchor" aria-label="anchor" href="#usage-1"></a></h4>
<p></p><div class="r"><div class="sourceCode"><pre><code><span><span class="va">LearnerSurvFlexible</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span>deep <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div><p></p></div>
</div>

<div class="section">
<h4 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h4>
<p></p><div class="arguments"><dl><dt><code>deep</code></dt>
<dd><p>Whether to make a deep clone.</p></dd>


</dl><p></p></div>
</div>

</div>

    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/therneau/survival" class="external-link">survival</a></span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Define the task, split to train/test set</span></span></span>
<span class="r-in"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html" class="external-link">tsk</a></span><span class="op">(</span><span class="st">"lung"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">part</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/partition.html" class="external-link">partition</a></span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Define the learner</span></span></span>
<span class="r-in"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html" class="external-link">lrn</a></span><span class="op">(</span><span class="st">"surv.flexible"</span>, k <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  formula <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">status</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">ph.karno</span> <span class="op">+</span> <span class="va">sex</span>,</span></span>
<span class="r-in"><span>  anc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>gamma1 <span class="op">=</span> <span class="op">~</span> <span class="va">sex</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Train the learner on the training ids</span></span></span>
<span class="r-in"><span><span class="va">learner</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">task</span>, <span class="va">part</span><span class="op">$</span><span class="va">train</span><span class="op">)</span></span></span>
<span class="r-err co"><span class="r-pr">#&gt;</span> <span class="error">Error in optim(method = "BFGS", par = c(gamma0 = 0.769559459031002, gamma1 = 0.809471579752982, gamma2 = -0.0867507621158821, age = 0.0112449832480452, ph.karno = -0.0412933200469301, sexm = 0.632805840429337, `gamma1(sexm)` = 0.04316080335661),     fn = function (optpars, ...)     {        pars[insert.locations] &lt;- optpars        raw.pars &lt;- pars        pars &lt;- as.list(pars)        pars.event &lt;- pars.nevent &lt;- pars        if (npars &gt; nbpars) {            beta &lt;- raw.pars[(nbpars + 1):npars]            for (i in dlist$pars) {                pars[[i]] &lt;- pars[[i]] + X[, mx[[i]], drop = FALSE] %*%                   beta[mx[[i]]]                pars.event[[i]] &lt;- pars[[i]][event]                pars.nevent[[i]] &lt;- pars[[i]][!event]            }        }        fnargs &lt;- c(par.transform(pars), aux.pars)        fnargs.event &lt;- c(par.transform(pars.event), aux.pars)        fnargs.nevent &lt;- c(par.transform(pars.nevent), aux.pars)        dargs &lt;- fnargs.event        dargs$x &lt;- event.times        dargs$log &lt;- TRUE        logdens &lt;- call_distfn_quiet(dfns$d, dargs)        if (!all(event)) {            pmaxargs &lt;- fnargs.nevent            pmaxargs$q &lt;- lcens.times            pmax &lt;- call_distfn_quiet(dfns$p, pmaxargs)            pmax[pmaxargs$q == Inf] &lt;- 1            pargs &lt;- fnargs.nevent            pargs$q &lt;- rcens.times            pmin &lt;- call_distfn_quiet(dfns$p, pargs)        }        targs &lt;- fnargs        targs$q &lt;- Y[, "start"]        plower &lt;- call_distfn_quiet(dfns$p, targs)        targs$q &lt;- rtrunc        pupper &lt;- call_distfn_quiet(dfns$p, targs)        pupper[rtrunc == Inf] &lt;- 1        pobs &lt;- pupper - plower        if (do.bhazard) {            pargs &lt;- fnargs.event            pargs$q &lt;- event.times            pminb &lt;- call_distfn_quiet(dfns$p, pargs)            logsurv_excess &lt;- log(1 - pminb)            loghaz_excess &lt;- logdens - logsurv_excess            haz_excess &lt;- exp(loghaz_excess)            logdens_offset &lt;- log(1 + bhazard[event]/haz_excess)            if (!all(event)) {                b_condsurv &lt;- 1 - bhazard[!event]                b_condsurv[lcens.times == Inf] &lt;- 0            }            if (any(is.finite(rtrunc)))                 stop("models with both right truncation and background hazards not supported")        }        else {            logdens_offset &lt;- 0        }        loglik[event] &lt;- (logdens + logdens_offset)        if (!all(event)) {            if (do.bhazard)                 loglik[!event] &lt;- log((pmax - 1) * b_condsurv +                   1 - pmin)            else loglik[!event] &lt;- log(pmax - pmin)        }        loglik &lt;- loglik - log(pobs)        ret &lt;- -sum(loglik * weights)        attr(ret, "indiv") &lt;- loglik        ret    }, gr = function (optpars, Y, X = 0, weights, bhazard, rtrunc,         dlist, inits, dfns, aux, mx, fixedpars = NULL)     {        pars &lt;- inits        npars &lt;- length(pars)        pars[setdiff(seq_len(npars), fixedpars)] &lt;- optpars        nbpars &lt;- length(dlist$pars)        pars &lt;- as.list(pars)        ncovs &lt;- length(pars) - length(dlist$pars)        if (ncovs &gt; 0)             beta &lt;- unlist(pars[(nbpars + 1):npars])        for (i in dlist$pars) {            if (length(mx[[i]]) &gt; 0)                 pars[[i]] &lt;- pars[[i]] + X[, mx[[i]], drop = FALSE] %*%                   beta[mx[[i]]]            else pars[[i]] &lt;- rep(pars[[i]], length(Y[, "stop"]))        }        dead &lt;- Y[, "status"] == 1        ddcall &lt;- list(t = Y[dead, "stop"])        dsccall &lt;- list(t = Y[!dead, "stop"])        dstcall &lt;- list(t = Y[, "start"])        for (i in 1:nbpars) ddcall[[names(pars)[i]]] &lt;- dsccall[[names(pars)[i]]] &lt;- dstcall[[names(pars)[i]]] &lt;- dlist$inv.transforms[[i]](pars[[i]])        for (i in seq_along(aux)) {            ddcall[[names(aux)[i]]] &lt;- dsccall[[names(aux)[i]]] &lt;- dstcall[[names(aux)[i]]] &lt;- aux[[i]]        }        for (i in dlist$pars) {            ddcall[[i]] &lt;- ddcall[[i]][dead]            dsccall[[i]] &lt;- dsccall[[i]][!dead]        }        nobs &lt;- nrow(Y)        dloglik &lt;- matrix(nrow = nobs, ncol = npars)        dloglik[dead, ] &lt;- dderiv(dfns$DLd, ddcall, X[dead, ,             drop = FALSE], mx, dlist)        dloglik[!dead, ] &lt;- dderiv(dfns$DLS, dsccall, X[!dead,             , drop = FALSE], mx, dlist)        dstrunc &lt;- dderiv(dfns$DLS, dstcall, X, mx, dlist)        dloglik &lt;- dloglik - dstrunc        if (any(bhazard &gt; 0)) {            dcall &lt;- ddcall            dcall$x &lt;- ddcall$t            dcall$t &lt;- NULL            dens &lt;- do.call(dfns$d, dcall)            pcall &lt;- dcall            pcall$q &lt;- pcall$x            pcall$x &lt;- NULL            surv &lt;- 1 - do.call(dfns$p, pcall)            haz &lt;- dens/surv            offseti &lt;- 1/(1 + bhazard[dead]/haz)            dscense &lt;- dderiv(dfns$DLS, ddcall, X[dead, , drop = FALSE],                 mx, dlist)            doff &lt;- -offseti * bhazard[dead] * (dloglik[dead,                 ] - dscense)/haz            dloglik[dead, ] &lt;- dloglik[dead, ] + doff        }        res &lt;- -colSums(dloglik * weights)        res[setdiff(1:npars, fixedpars)]    }, Y = structure(c(455, 210, 310, 361, 567, 613, 61, 301,     371, 118, 390, 473, 26, 107, 93, 731, 460, 153, 95, 303,     519, 643, 53, 246, 689, 5, 687, 345, 444, 60, 163, 65, 230,     840, 305, 705, 363, 176, 95, 167, 806, 284, 147, 163, 655,     245, 477, 450, 156, 529, 351, 15, 181, 283, 212, 288, 199,     550, 92, 60, 551, 353, 267, 511, 457, 201, 404, 222, 62,     458, 353, 31, 229, 156, 329, 291, 179, 376, 384, 268, 142,     413, 181, 285, 301, 348, 197, 382, 180, 269, 300, 284, 292,     332, 285, 110, 270, 225, 225, 276, 135, 59, 202, 235, 239,     221, 185, 222, 175, 197, 203, 174, 177, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,     1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,     0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0,     1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1,     1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 455, 210, 310, 361, 567,     613, 61, 301, 371, 118, 390, 473, 26, 107, 93, 731, 460,     153, 95, 303, 519, 643, 53, 246, 689, 5, 687, 345, 444, 60,     163, 65, 230, 840, 305, 705, 363, 176, 95, 167, 806, 284,     147, 163, 655, 245, 477, 450, 156, 529, 351, 15, 181, 283,     212, 288, 199, 550, 92, 60, 551, 353, 267, 511, 457, 201,     404, 222, 62, 458, 353, 31, 229, 156, 329, 291, 179, 376,     384, 268, 142, 413, 181, 285, 301, 348, 197, 382, 180, 269,     300, 284, 292, 332, 285, 110, 270, 225, 225, 276, 135, 59,     202, 235, 239, 221, 185, 222, 175, 197, 203, 174, 177, 455,     210, 310, 361, 567, 613, 61, 301, 371, 118, 390, 473, 26,     107, 93, 731, 460, 153, 95, 303, 519, 643, 53, 246, 689,     5, 687, 345, 444, 60, 163, 65, 230, 840, 305, 705, 363, 176,     95, 167, 806, 284, 147, 163, 655, 245, 477, 450, 156, 529,     351, 15, 181, 283, 212, 288, 199, 550, 92, 60, 551, 353,     267, 511, 457, 201, 404, 222, 62, 458, 353, 31, 229, 156,     329, 291, 179, 376, 384, 268, 142, 413, 181, 285, 301, 348,     197, 382, 180, 269, 300, 284, 292, 332, 285, 110, 270, 225,     225, 276, 135, 59, 202, 235, 239, 221, 185, 222, 175, 197,     203, 174, 177, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf), dim = c(113L, 6L    ), dimnames = list(c("1", "2", "3", "4", "5", "6", "7", "8",     "9", "10", "11", "12", "13", "14", "15", "16", "17", "18",     "19", "20", "21", "22", "23", "24", "25", "26", "27", "28",     "29", "30", "31", "32", "33", "34", "35", "36", "37", "38",     "39", "40", "41", "42", "43", "44", "45", "46", "47", "48",     "49", "50", "51", "52", "53", "54", "55", "56", "57", "58",     "59", "60", "61", "62", "63", "64", "65", "66", "67", "68",     "69", "70", "71", "72", "73", "74", "75", "76", "77", "78",     "79", "80", "81", "82", "83", "84", "85", "86", "87", "88",     "89", "90", "91", "92", "93", "94", "95", "96", "97", "98",     "99", "100", "101", "102", "103", "104", "105", "106", "107",     "108", "109", "110", "111", "112", "113"), c("time", "status",     "start", "stop", "time1", "time2")), type = "right"), X = structure(c(68,     57, 68, 71, 57, 70, 56, 67, 58, 70, 53, 69, 73, 60, 74, 64,     70, 73, 76, 74, 63, 74, 68, 58, 59, 65, 58, 64, 75, 65, 69,     68, 67, 63, 48, 51, 56, 73, 55, 44, 44, 71, 61, 72, 63, 57,     64, 69, 66, 54, 75, 69, 44, 80, 49, 66, 60, 69, 50, 64, 77,     47, 67, 74, 54, 73, 74, 76, 65, 57, 71, 82, 70, 55, 69, 62,     63, 56, 62, 44, 63, 64, 61, 65, 61, 58, 56, 43, 56, 74, 60,     39, 51, 45, 72, 64, 72, 64, 70, 52, 60, 73, 50, 63, 50, 67,     69, 65, 57, 67, 71, 66, 58, 90, 90, 70, 60, 80, 90, 60, 80,     90, 60, 80, 90, 60, 50, 50, 80, 80, 60, 60, 90, 80, 90, 90,     100, 90, 100, 80, 90, 70, 90, 80, 70, 80, 90, 80, 100, 80,     90, 70, 80, 80, 80, 100, 70, 100, 80, 90, 80, 80, 80, 60,     90, 80, 80, 70, 70, 70, 70, 80, 80, 80, 100, 90, 60, 90,     70, 80, 70, 80, 80, 100, 100, 70, 70, 70, 70, 80, 80, 90,     90, 90, 80, 90, 100, 90, 90, 90, 100, 60, 100, 100, 100,     90, 90, 70, 80, 80, 90, 100, 100, 90, 60, 100, 100, 60, 80,     90, 90, 80, 80, 80, 90, 80, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1,     1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,     0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0,     1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1,     1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0,     1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0,     1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1,     0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,     1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1,     0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1,     0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1,     0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,     1, 1, 0, 1, 0, 1, 0), dim = c(113L, 4L), dimnames = list(        c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10",         "11", "12", "13", "14", "15", "16", "17", "18", "19",         "20", "21", "22", "23", "24", "25", "26", "27", "28",         "29", "30", "31", "32", "33", "34", "35", "36", "37",         "38", "39", "40", "41", "42", "43", "44", "45", "46",         "47", "48", "49", "50", "51", "52", "53", "54", "55",         "56", "57", "58", "59", "60", "61", "62", "63", "64",         "65", "66", "67", "68", "69", "70", "71", "72", "73",         "74", "75", "76", "77", "78", "79", "80", "81", "82",         "83", "84", "85", "86", "87", "88", "89", "90", "91",         "92", "93", "94", "95", "96", "97", "98", "99", "100",         "101", "102", "103", "104", "105", "106", "107", "108",         "109", "110", "111", "112", "113"), c("age", "ph.karno",         "sexm", gamma1 = "gamma1(sexm)"))), weights = c(1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), bhazard = c(0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), rtrunc = c(Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,     Inf, Inf, Inf, Inf), dlist = list(name = "survspline", pars = c("gamma0",     "gamma1", "gamma2"), location = "gamma0", transforms = list(        function (x)         x, function (x)         x, function (x)         x), inv.transforms = list(function (x)     x, function (x)     x, function (x)     x), inits = function (t, mf, mml, aux)     {        aux$skip.pd.check &lt;- TRUE        inits &lt;- flexsurv.splineinits(t = t, mf = mf, mml = mml,             aux = aux)        Y &lt;- check.flexsurv.response(model.extract(mf, "response"))        intcens &lt;- Y[, "status"] == 3 &amp; (Y[, "start"] &lt; Y[, "stop"])        Y[intcens, "status"] &lt;- 1        Y[intcens, "stop"] &lt;- Y[intcens, "start"] + (Y[intcens,             "stop"] - Y[intcens, "start"])/2        Y[, "status"] &lt;- ifelse(Y[, "status"] == 1, 1, 0)        inc &lt;- Y[, "start"] &lt; Y[, "stop"]        X &lt;- mml[[1]][, -1, drop = FALSE]        formdat &lt;- as.data.frame(cbind(Y, X, weights = model.extract(mf,             "weights")))        names(formdat)[1:ncol(Y)] &lt;- colnames(Y)        form &lt;- c("Surv(start, stop, status) ~")        if (ncol(X) &gt; 0) {            names(formdat)[ncol(Y) + 1:ncol(X)] &lt;- paste0("X",                 1:ncol(X))            form &lt;- paste(form, paste(paste0("X", 1:ncol(X)),                 collapse = " + "))            formdat &lt;- formdat[inc, ]            cox &lt;- coxph(as.formula(form), weights = weights,                 data = formdat)            covinds &lt;- length(aux$knots) + 1:ncol(X)            inits[covinds] &lt;- coef(cox)        }        inits    }), inits = c(gamma0 = 0.769559459031002, gamma1 = 0.809471579752982,     gamma2 = -0.0867507621158821, age = 0.0112449832480452, ph.karno = -0.0412933200469301,     sexm = 0.632805840429337, `gamma1(sexm)` = 0.04316080335661    ), dfns = list(p = function (q, beta = 0, X = 0, knots = c(-10,         10), scale = "hazard", timescale = "log", spline = "rp",         offset = 0, lower.tail = TRUE, log.p = FALSE, gamma0,         gamma1, gamma2)     {        base.fn &lt;- function(q, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0, lower.tail = TRUE, log.p = FALSE) {            betax_warn(beta, X, offset)            d &lt;- dbase.survspline(q = q, gamma = gamma, knots = knots,                 scale = scale, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            if (any(ind)) {                ret[ind][q == 0] &lt;- 0                ret[ind][q == Inf] &lt;- 1                finite &lt;- q &gt; 0 &amp; q &lt; Inf                ind[ind][!finite] &lt;- FALSE                q &lt;- q[finite]                gamma &lt;- gamma[finite, , drop = FALSE]                knots &lt;- knots[finite, , drop = FALSE]            }            if (any(ind)) {                eta &lt;- rowSums(basis(knots, tsfn(q, timescale),                   spline = spline) * gamma) + as.numeric(X %*%                   beta)                surv &lt;- Slink(scale)(eta)                ret[ind] &lt;- as.numeric(1 - surv)            }            if (!lower.tail)                 ret &lt;- 1 - ret            if (log.p)                 ret &lt;- log(ret)            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(q = q, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, lower.tail = lower.tail, log.p = log.p,             gamma = gamma))    }, d = function (x, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         log = FALSE, gamma0, gamma1, gamma2)     {        base.fn &lt;- function(x, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0, log = FALSE) {            betax_warn(beta, X, offset)            d &lt;- dbase.survspline(q = x, gamma = gamma, knots = knots,                 scale = scale, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            if (any(ind)) {                eta &lt;- rowSums(basis(knots, tsfn(q, timescale),                   spline = spline) * gamma)                eeta &lt;- exp(ldlink(scale)(eta))                ret[ind][eeta == 0] &lt;- 0                ret[ind][is.nan(eeta)] &lt;- NaN                ind2 &lt;- !(eeta == 0 | is.nan(eeta))                q &lt;- q[ind2]                gamma &lt;- gamma[ind2, , drop = FALSE]                knots &lt;- knots[ind2, , drop = FALSE]                eeta &lt;- eeta[ind2]                ind[ind] &lt;- ind[ind] &amp; ind2                dsum &lt;- rowSums(dbasis(knots, tsfn(q, timescale),                   spline = spline) * gamma)                ret[ind] &lt;- dtsfn(q, timescale) * dsum * eeta                ret[ind][ret[ind] &lt;= 0] &lt;- 0            }            if (log) {                ret &lt;- log(ret)            }            as.numeric(ret)        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(x = x, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, log = log, gamma = gamma))    }, h = function (x, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         gamma0, gamma1, gamma2)     {        base.fn &lt;- function(x, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0) {            betax_warn(beta, X, offset)            match.arg(scale, c("hazard", "odds", "normal"))            d &lt;- dbase.survspline(q = x, gamma = gamma, knots = knots,                 scale = scale, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            if (any(ind)) {                eta &lt;- rowSums(basis(knots, tsfn(q, timescale),                   spline = spline) * gamma) + as.numeric(X %*%                   beta)                eeta &lt;- hlink(scale)(eta)                ret[ind] &lt;- dtsfn(q, timescale) * rowSums(dbasis(knots,                   tsfn(q, timescale), spline = spline) * gamma) *                   eeta                ret[ind][ret[ind] &lt;= 0] &lt;- 0            }            as.numeric(ret)        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(x = x, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, gamma = gamma))    }, H = function (x, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         gamma0, gamma1, gamma2)     {        base.fn &lt;- function(x, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0) {            match.arg(scale, c("hazard", "odds", "normal"))            d &lt;- dbase.survspline(q = x, gamma = gamma, knots = knots,                 scale = scale, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            if (any(ind)) {                eta &lt;- rowSums(basis(knots, tsfn(q, timescale),                   spline = spline) * gamma) + as.numeric(X %*%                   beta)                ret[ind] &lt;- as.numeric(Hlink(scale)(eta))            }            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(x = x, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, gamma = gamma))    }, r = function (n, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         gamma0, gamma1, gamma2)     {        base.fn &lt;- function(n, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0) {            betax_warn(beta, X, offset)            if (length(n) &gt; 1)                 n &lt;- length(n)            ret &lt;- qsurvspline(p = runif(n), gamma = gamma, knots = knots,                 scale = scale, timescale = timescale, spline = spline)            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(n = n, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, gamma = gamma))    }, DLd = function (t, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", gamma0,         gamma1, gamma2)     {        base.fn &lt;- function(t, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp") {            d &lt;- dbase.survspline(q = t, gamma = gamma, knots = knots,                 scale = scale, deriv = 1, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            t &lt;- q            b &lt;- basis(knots, tsfn(t, timescale), spline = spline)            db &lt;- dbasis(knots, tsfn(t, timescale), spline = spline)            eta &lt;- rowSums(b * gamma) + as.numeric(X %*% beta)            ds &lt;- rowSums(db * gamma)            npars &lt;- ncol(gamma)            parnames &lt;- paste0("gamma", seq_len(npars) - 1)            colnames(ret) &lt;- parnames            for (i in 1:ncol(gamma)) {                if (scale == "hazard")                   ret[ind, i] &lt;- db[, i]/ds + b[, i] * (1 - exp(eta))                else if (scale == "odds") {                  eeta &lt;- 1 - 2 * exp(eta)/(1 + exp(eta))                  ret[ind, i] &lt;- db[, i]/ds + b[, i] * eeta                }            }            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(t = t, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             gamma = gamma))    }, DLS = function (t, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", gamma0,         gamma1, gamma2)     {        base.fn &lt;- function(t, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp") {            d &lt;- dbase.survspline(q = t, gamma = gamma, knots = knots,                 scale = scale, deriv = 1, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            t &lt;- q            b &lt;- basis(knots, tsfn(t, timescale), spline = spline)            if (any(ind)) {                eta &lt;- rowSums(b * gamma) + as.numeric(X %*%                   beta)                for (i in 1:ncol(gamma)) {                  if (scale == "hazard")                     ret[ind, i] &lt;- ifelse(t == 0, 0, -b[, i] *                       exp(eta))                  else if (scale == "odds") {                    eeta &lt;- exp(eta)/(1 + exp(eta))                    ret[ind, i] &lt;- ifelse(t == 0, 0, -b[, i] *                       eeta)                  }                }            }            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(t = t, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             gamma = gamma))    }, D2Ld = function (t, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", gamma0,         gamma1, gamma2)     {        base.fn &lt;- function(t, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp") {            d &lt;- dbase.survspline(q = t, gamma = gamma, knots = knots,                 scale = scale, deriv = 2, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            t &lt;- q            b &lt;- basis(knots, tsfn(t, timescale), spline = spline)            db &lt;- dbasis(knots, tsfn(t, timescale), spline = spline)            eta &lt;- rowSums(b * gamma) + as.numeric(X %*% beta)            ds &lt;- rowSums(db * gamma)            if (scale == "odds") {                eeta &lt;- 2 * exp(eta)/(1 + exp(eta))^2                db &lt;- dbasis(knots, tsfn(t, timescale), spline = spline)            }            npars &lt;- ncol(gamma)            for (i in 1:npars) {                for (j in 1:npars) {                  if (scale == "hazard")                     ret[ind, i, j] &lt;- -db[, i] * db[, j]/ds^2 -                       b[, i] * b[, j] * exp(eta)                  else if (scale == "odds")                     ret[ind, i, j] &lt;- -db[, i] * db[, j]/ds^2 -                       b[, i] * b[, j] * eeta                }            }            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(t = t, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             gamma = gamma))    }, D2LS = function (t, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", gamma0,         gamma1, gamma2)     {        base.fn &lt;- function(t, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp") {            tmp_gamma &lt;- gamma            tmp_t &lt;- t            tmp_knots &lt;- knots            d &lt;- dbase.survspline(q = t, gamma = gamma, knots = knots,                 scale = scale, deriv = 2, spline = spline)            for (i in seq_along(d)) assign(names(d)[i], d[[i]])            t &lt;- q            b &lt;- basis(knots, tsfn(t, timescale), spline = spline)            npars &lt;- ncol(gamma)            if (length(t) &gt; 0) {                eta &lt;- rowSums(b * gamma) + as.numeric(X %*%                   beta)                if (scale == "odds") {                  eeta &lt;- exp(eta)/(1 + exp(eta))^2                }                for (i in 1:npars) {                  for (j in 1:npars) {                    if (scale == "hazard")                       ret[ind, i, j] &lt;- ifelse(t == 0, 0, -b[,                         i] * b[, j] * exp(eta))                    else if (scale == "odds")                       ret[ind, i, j] &lt;- ifelse(t == 0, 0, -b[,                         i] * b[, j] * eeta)                  }                }            }            ret        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(t = t, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             gamma = gamma))    }, rmst = function (t, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         start = 0, gamma0, gamma1, gamma2)     {        base.fn &lt;- function(t, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0, start = 0) {            betax_warn(beta, X, offset)            rmst_generic(psurvspline, t, start = start, matargs = c("gamma",                 "knots"), scalarargs = c("scale", "timescale",                 "spline"), gamma = gamma, knots = knots, scale = scale,                 timescale = timescale, spline = spline)        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(t = t, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, start = start, gamma = gamma))    }, mean = function (beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         gamma0, gamma1, gamma2)     {        base.fn &lt;- function(gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0) {            betax_warn(beta, X, offset)            nt &lt;- if (is.matrix(gamma))                 nrow(gamma)            else 1            rmst_generic(psurvspline, rep(Inf, nt), start = 0,                 matargs = c("gamma", "knots"), scalarargs = c("scale",                   "timescale", "spline"), gamma = gamma, knots = knots,                 scale = scale, timescale = timescale, spline = spline)        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, gamma = gamma))    }, q = function (p, beta = 0, X = 0, knots = c(-10, 10),         scale = "hazard", timescale = "log", spline = "rp", offset = 0,         lower.tail = TRUE, log.p = FALSE, gamma0, gamma1, gamma2)     {        base.fn &lt;- function(p, gamma, beta = 0, X = 0, knots = c(-10,             10), scale = "hazard", timescale = "log", spline = "rp",             offset = 0, lower.tail = TRUE, log.p = FALSE) {            betax_warn(beta, X, offset)            if (log.p)                 p &lt;- exp(p)            if (!lower.tail)                 p &lt;- 1 - p            qgeneric(psurvspline, p = p, matargs = c("gamma",                 "knots"), scalarargs = c("scale", "timescale",                 "spline"), gamma = gamma, knots = knots, scale = scale,                 timescale = timescale, spline = spline)        }        gamma &lt;- do.call("cbind", list(gamma0, gamma1, gamma2))        do.call(base.fn, list(p = p, beta = beta, X = X, knots = knots,             scale = scale, timescale = timescale, spline = spline,             offset = offset, lower.tail = lower.tail, log.p = log.p,             gamma = gamma))    }, deriv = TRUE, hessian = TRUE), aux = list(knots = c(1.6094379124341,     `50%` = 5.50125821054473, 6.59441345974978), scale = "hazard",         timescale = "log", spline = "rp"), mx = list(gamma0 = 1:3,         gamma1 = 4L, gamma2 = NULL), fixedpars = NULL, hessian = FALSE):</span> initial value in 'vmmin' is not finite</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">learner</span><span class="op">$</span><span class="va">model</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Make predictions for the test rows</span></span></span>
<span class="r-in"><span><span class="va">predictions</span> <span class="op">=</span> <span class="va">learner</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span><span class="va">task</span>, <span class="va">part</span><span class="op">$</span><span class="va">test</span><span class="op">)</span></span></span>
<span class="r-err co"><span class="r-pr">#&gt;</span> <span class="error">Error:</span> Cannot predict, Learner 'surv.flexible' has not been trained yet</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">predictions</span><span class="op">)</span></span></span>
<span class="r-err co"><span class="r-pr">#&gt;</span> <span class="error">Error in h(simpleError(msg, call)):</span> error in evaluating the argument 'x' in selecting a method for function 'print': object 'predictions' not found</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Score the predictions</span></span></span>
<span class="r-in"><span><span class="va">predictions</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-err co"><span class="r-pr">#&gt;</span> <span class="error">Error:</span> object 'predictions' not found</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Raphael Sonabend, <a href="https://pat-s.me" class="external-link">Patrick Schratz</a>, Sebastian Fischer, John Zobolas.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

